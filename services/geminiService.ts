
import { GoogleGenAI, Modality } from "@google/genai";
import type { MapStyle } from '../types';

export const createAiClient = (apiKey: string): GoogleGenAI => {
    if (!apiKey) {
        throw new Error("An API key is required to create the AI client.");
    }
    return new GoogleGenAI({ apiKey });
};

export const generateMapFromDrawing = async (ai: GoogleGenAI, blueprintBase64: string, prompt: string): Promise<string> => {
  try {
    const blueprintPart = {
      inlineData: {
        mimeType: 'image/png',
        data: blueprintBase64.split(',')[1],
      },
    };

    const textPart = { text: prompt };

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image-preview',
      contents: {
        parts: [
          { text: "This is the color-coded blueprint for the terrains:" },
          blueprintPart,
          textPart
        ],
      },
      config: {
        responseModalities: [Modality.IMAGE, Modality.TEXT],
      },
    });

    // Find the image part in the response
    const imageResponsePart = response.candidates?.[0]?.content?.parts?.find(
      (part) => part.inlineData
    );

    if (imageResponsePart?.inlineData) {
      const base64ImageBytes = imageResponsePart.inlineData.data;
      return `data:image/png;base64,${base64ImageBytes}`;
    } else {
      // Check for text part which might contain a refusal or error
      const textResponse = response.text;
      if (textResponse) {
        throw new Error(`API returned a text response instead of an image: ${textResponse}`);
      }
      throw new Error("No image was generated by the API.");
    }
  } catch (error) {
    console.error("Error generating image with Gemini API:", error);
    if (error instanceof Error) {
        // Re-throw the error with context, preserving the original message for parsing.
        throw new Error(`Failed to generate map: ${error.message}`);
    }
    // For unknown non-Error types caught.
    throw new Error("An unknown error occurred while generating the map. Check the console for details.");
  }
};

export const refineGeneratedMap = async (ai: GoogleGenAI, initialMapBase64: string, style: MapStyle): Promise<string> => {
    let stylePreamble = '';
    let styleInstruction = '';

    switch (style) {
        case 'pixel':
            stylePreamble = 'You are an AI image refiner specializing in **16-bit pixel art**.';
            styleInstruction = 'Repaint with Texture: Replace the flat color with a high-quality, 16-bit pixel art texture that logically continues the terrain from the surrounding, correctly textured areas. Infer the correct terrain type from the context of what is adjacent to the flat patch. The new texture must be pure pixel art and match the style of the rest of the map. Do not use anti-aliasing or smooth gradients.';
            break;
        case 'photorealistic':
        default:
            stylePreamble = 'You are an AI image refiner.';
            styleInstruction = 'Repaint with Texture: Replace the flat color with a high-quality, photorealistic texture that logically continues the terrain from the surrounding, correctly textured areas. Infer the correct terrain type from the context of what is adjacent to the flat patch.';
            break;
    }

    const refinementPrompt = `**AI Directive: Targeted Map In-Painting**

${stylePreamble} You have been given a fantasy map that contains flawsâ€”specifically, patches of flat, un-textured color. Your sole task is to fix these flawed areas by in-painting them.

**Your Instructions:**

1.  **Contextual In-Painting:** Find all areas of flat, un-textured color on the provided "Generated Map". For each of these areas, perform a targeted "in-painting" operation:
    *   **${styleInstruction}**
    *   **Seamless Blending:** The edges of your repainted textures MUST blend perfectly and naturally with the surrounding, correctly rendered parts of the map.

2.  **Preservation:** You are FORBIDDEN from altering any pixels outside of the identified flat zones. The correctly textured parts of the map must remain untouched, only using them as context for your in-painting.

**Crucial Constraint:** Your output MUST be only the corrected image of the fantasy map. Do not add new features or change the composition. Simply fix the flawed textures by intelligently filling them in.`;
    
    try {
        const initialMapPart = {
          inlineData: {
            mimeType: 'image/png',
            data: initialMapBase64.split(',')[1],
          },
        };

        const response = await ai.models.generateContent({
          model: 'gemini-2.5-flash-image-preview',
          contents: {
            parts: [
              { text: "This is the generated map which has flaws that need to be fixed:" },
              initialMapPart,
              { text: refinementPrompt },
            ]
          },
          config: {
            responseModalities: [Modality.IMAGE, Modality.TEXT],
          },
        });
        
        const imagePart = response.candidates?.[0]?.content?.parts?.find(p => p.inlineData);

        if (imagePart?.inlineData) {
          const base64ImageBytes = imagePart.inlineData.data;
          return `data:image/png;base64,${base64ImageBytes}`;
        }
        
        const textResponse = response.text;
        if (textResponse) {
            throw new Error(`API returned an unexpected text response during refinement: ${textResponse}`);
        }
        
        throw new Error("No image was generated by the API during refinement.");

    } catch (error) {
        console.error("Error refining image with a Gemini API:", error);
        if (error instanceof Error) {
            throw new Error(`Failed to refine map: ${error.message}`);
        }
        throw new Error("An unknown error occurred while refining the map. Check the console for details.");
    }
};
